# 网球社交平台技术实践路径

## 技术栈概述

### 前端技术栈
- **核心框架:** Flutter
- **编程语言:** Dart
- **UI 设计规范:** Material Design 3
- **状态管理:** Riverpod
- **路由导航:** go_router
- **网络请求:** dio
- **本地存储:** shared_preferences
- **屏幕适配:** flutter_screenutil
### 后端技术栈
- **核心框架:** Python + FastAPI
- **数据库:** PostgreSQL (本地开发 → 云 RDS 迁移)
- **ORM:** SQLAlchemy
- **数据库迁移:** Alembic
- **认证:** JWT (python-jose)
- **密码加密:** passlib[bcrypt]

## 一、开发环境准备

### 1.1 开发工具安装

#### 前端开发环境 (Flutter)
```bash
# Flutter SDK (核心框架)
# 下载地址: https://flutter.dev/docs/get-started/install
# Windows: 下载 zip 并解压到 C:\src\flutter
# Mac: 使用 Homebrew: brew install flutter
# Linux: 下载 tar.xz 并解压

# 配置环境变量 (Windows)
# 将 C:\src\flutter\bin 添加到 PATH

# 验证安装
flutter doctor

# Android Studio (Android 开发必需)
# 下载地址: https://developer.android.com/studio
# 安装 Flutter 和 Dart 插件

# Xcode (iOS 开发，仅 Mac)
# Mac App Store 下载
# 安装 Command Line Tools: xcode-select --install

# VS Code (推荐的轻量级编辑器)
# 下载地址: https://code.visualstudio.com/
# 安装 Flutter 和 Dart 插件
```

#### 后端开发环境
```bash
# Python 3.9+ (核心语言)
# 下载地址: https://www.python.org/downloads/

# FastAPI (核心框架)
# 通过 requirements.txt 安装，详见项目初始化部分

# 安装 Poetry (推荐的依赖管理工具)
pip install poetry

# 或使用 pip + virtualenv
pip install virtualenv
```

#### 数据库工具
```bash
# PostgreSQL (核心数据库)
# 开发阶段: 本地 PostgreSQL
# 生产阶段: 云 RDS 服务 (阿里云 RDS / AWS RDS)

# 本地安装 PostgreSQL
# Windows: https://www.postgresql.org/download/windows/
# Mac: brew install postgresql@15
# Linux: sudo apt install postgresql-15

# 启动本地 PostgreSQL
# Windows: 自动启动服务
# Mac: brew services start postgresql@15
# Linux: sudo systemctl start postgresql

# 数据库管理工具
# DBeaver: https://dbeaver.io/ (推荐，跨平台)
# pgAdmin: https://www.pgadmin.org/ (PostgreSQL 官方)
# TablePlus: https://tableplus.com/ (Mac/Windows，界面美观)
```

#### 版本控制
```bash
# Git
# 下载地址: https://git-scm.com/

# 初始化仓库
git init
```

### 1.2 IDE 推荐
- **前端：** Android Studio (功能完整) 或 VS Code (轻量级) + Flutter/Dart 插件
- **后端：** PyCharm / VS Code + Python 插件
- **数据库：** DBeaver Community

### 1.3 Flutter 开发基础介绍

#### 什么是 Flutter？
Flutter 是 Google 开发的开源 UI 框架，用于从单一代码库构建跨平台应用（iOS、Android、Web、Desktop）。

**核心特点：**
- **一套代码，多端运行**：真正的跨平台，不是 WebView 包装
- **高性能**：直接编译为原生代码，性能接近原生应用
- **热重载**：修改代码后秒级刷新，极大提升开发效率
- **丰富的 UI 组件**：Material Design 和 Cupertino 风格组件库
- **声明式 UI**：类似 React，使用 Widget 树构建界面

#### Dart 语言快速入门
Dart 语法类似 Java/JavaScript/TypeScript，易于上手。

**核心语法：**
```dart
// 变量
var name = 'Tennis App';        // 自动推断
String title = '网球社交平台';   // 显式类型
final userId = 123;              // 运行时常量（不可变）
const apiUrl = 'https://...';    // 编译时常量

// 函数
String greet(String name) => 'Hello, $name';  // 箭头函数

// 类
class User {
  final int id;
  final String name;
  User({required this.id, required this.name});  // 命名参数
}

// 异步
Future<String> fetchData() async {
  await Future.delayed(Duration(seconds: 1));
  return 'Data loaded';
}

// 空安全
String? nullable;     // 可为 null
String nonNull = '';  // 不可为 null
```

#### Flutter Widget 基础
Flutter 中一切皆 Widget，UI 由 Widget 树构成。

**常用 Widget：**
```dart
// 布局
Container()  // 容器
Row()        // 水平布局
Column()     // 垂直布局
ListView()   // 列表

// 基础组件
Text()           // 文本
Image()          // 图片
ElevatedButton() // 按钮
TextField()      // 输入框
Card()           // 卡片
AppBar()         // 顶部栏
```

**简单示例：**
```dart
// 使用 Riverpod 的组件（推荐）
class MyWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final data = ref.watch(myProvider);
    return Text(data);
  }
}
```

## 二、项目初始化

### 2.1 项目结构设计

```
tennis_app/
├── flutter_app/           # Flutter 前端应用
│   ├── lib/
│   │   ├── main.dart     # 应用入口
│   │   ├── screens/      # 页面
│   │   ├── widgets/      # 通用组件
│   │   ├── models/       # 数据模型
│   │   ├── providers/    # Provider 状态管理
│   │   ├── services/     # API 服务
│   │   ├── routes/       # 路由配置
│   │   ├── utils/        # 工具函数
│   │   └── config/       # 配置文件
│   ├── assets/           # 静态资源
│   │   ├── images/
│   │   └── fonts/
│   ├── android/          # Android 原生配置
│   ├── ios/              # iOS 原生配置
│   ├── pubspec.yaml      # Flutter 依赖配置
│   └── analysis_options.yaml  # Dart 代码规范
│
├── backend/              # FastAPI 后端
│   ├── app/
│   │   ├── api/         # API 路由
│   │   ├── models/      # 数据模型
│   │   ├── schemas/     # Pydantic schemas
│   │   ├── services/    # 业务逻辑
│   │   ├── core/        # 核心配置
│   │   ├── db/          # 数据库配置
│   │   └── utils/       # 工具函数
│   ├── alembic/         # 数据库迁移
│   ├── tests/           # 测试文件
│   ├── requirements.txt
│   └── main.py
│
├── docs/                 # 文档
├── .gitignore
└── README.md
```

### 2.2 初始化 Flutter 项目

```bash
# 创建 Flutter 项目
flutter create tennis_app
cd tennis_app

# 或者指定组织名（用于包名）
flutter create --org com.tennis tennis_app

# 项目创建后的基本命令
flutter doctor          # 检查环境
flutter pub get         # 安装依赖
flutter run            # 运行应用（需连接设备或模拟器）
flutter run -d chrome  # 在浏览器运行（Web）

# 查看可用设备
flutter devices

# 运行在特定设备
flutter run -d <device_id>
```

#### 配置 pubspec.yaml（依赖管理）

编辑 `flutter_app/pubspec.yaml`，添加项目依赖：

```yaml
name: tennis_app
description: 网球社交平台移动应用
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  
  # UI 相关
  cupertino_icons: ^1.0.6
  flutter_screenutil: ^5.9.0  # 屏幕适配
  
  # 状态管理
  flutter_riverpod: ^2.4.9
  
  # 路由导航
  go_router: ^13.0.0
  
  # 网络请求
  dio: ^5.4.0
  
  # 本地存储
  shared_preferences: ^2.2.2
  
  # JSON 序列化
  json_annotation: ^4.8.1
  
  # 图片相关
  image_picker: ^1.0.7
  cached_network_image: ^3.3.1
  
  # 其他工具
  intl: ^0.19.0  # 国际化
  logger: ^2.0.2  # 日志

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.1
  
  # JSON 序列化代码生成
  build_runner: ^2.4.8
  json_serializable: ^6.7.1

flutter:
  uses-material-design: true
  
  # 静态资源
  assets:
    - assets/images/
    - assets/icons/
  
  # 自定义字体（可选）
  # fonts:
  #   - family: CustomFont
  #     fonts:
  #       - asset: assets/fonts/CustomFont-Regular.ttf
```

```bash
# 安装依赖
flutter pub get

# 如果使用代码生成（JSON 序列化）
flutter pub run build_runner build --delete-conflicting-outputs
```

### 2.3 初始化 FastAPI 项目 (Python + FastAPI)

```bash
# 创建项目目录
mkdir backend
cd backend

# 创建虚拟环境
python -m venv venv

# 激活虚拟环境
# Windows:
venv\Scripts\activate
# Mac/Linux:
source venv/bin/activate

# 创建 requirements.txt
# 核心依赖：FastAPI + PostgreSQL (psycopg2-binary)
```

**requirements.txt 内容：**
```txt
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
psycopg2-binary==2.9.9
alembic==1.12.1
pydantic==2.5.0
pydantic-settings==2.1.0
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
aiofiles==23.2.1
pillow==10.1.0
python-dotenv==1.0.0
httpx==0.25.2
pytest==7.4.3
pytest-asyncio==0.21.1
```

```bash
# 安装依赖
pip install -r requirements.txt
```

## 三、后端开发实践 (Python + FastAPI + PostgreSQL)

### 3.1 PostgreSQL 数据库配置

#### 本地开发环境配置

**步骤 1：创建本地数据库**

```bash
# 连接到 PostgreSQL (默认用户 postgres)
# Windows: 使用 SQL Shell (psql) 或 pgAdmin
# Mac/Linux: 
psql -U postgres

# 创建数据库
CREATE DATABASE tennis_db;

# 创建专用用户（可选，推荐）
CREATE USER tennis_user WITH PASSWORD 'your_password';

# 授予权限
GRANT ALL PRIVILEGES ON DATABASE tennis_db TO tennis_user;

# 退出
\q
```

**步骤 2：配置环境变量**

创建 `backend/.env` 文件：

```env
# 本地开发数据库配置
DATABASE_URL=postgresql://tennis_user:your_password@localhost:5432/tennis_db

# 或使用默认 postgres 用户
# DATABASE_URL=postgresql://postgres:postgres@localhost:5432/tennis_db
```

#### 云 RDS 迁移配置

**生产环境配置（阿里云 RDS 示例）：**

```env
# 生产环境数据库配置
DATABASE_URL=postgresql://username:password@rm-xxxxx.pg.rds.aliyuncs.com:5432/tennis_db

# 注意事项：
# 1. 使用阿里云 RDS 实例的内网地址（更快更安全）
# 2. 配置白名单允许 ECS 访问
# 3. 使用强密码
# 4. 启用 SSL 连接（推荐）
```

**迁移步骤：**

1. **导出本地数据**
```bash
# 导出本地数据库
pg_dump -U tennis_user -h localhost tennis_db > tennis_db_backup.sql
```

2. **导入到云 RDS**
```bash
# 导入到阿里云 RDS
psql -h rm-xxxxx.pg.rds.aliyuncs.com -U username -d tennis_db < tennis_db_backup.sql
```

3. **更新环境变量**
```bash
# 修改 .env 文件中的 DATABASE_URL
# 重启应用
```

#### 创建数据库配置文件

**backend/app/core/config.py**
```python
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    # 数据库配置
    DATABASE_URL: str = "postgresql://username:password@localhost:5432/tennis_db"
    
    # JWT 配置
    SECRET_KEY: str = "your-secret-key-change-in-production"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # 阿里云 OSS 配置
    ALIYUN_OSS_ACCESS_KEY_ID: Optional[str] = None
    ALIYUN_OSS_ACCESS_KEY_SECRET: Optional[str] = None
    ALIYUN_OSS_BUCKET_NAME: Optional[str] = None
    ALIYUN_OSS_ENDPOINT: Optional[str] = None
    
    # 应用配置
    APP_NAME: str = "Tennis Social Platform"
    DEBUG: bool = True
    
    class Config:
        env_file = ".env"

settings = Settings()
```

**backend/app/db/database.py**
```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

engine = create_engine(settings.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

# 数据库依赖注入
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### 3.2 数据模型定义

**backend/app/models/user.py**
```python
from sqlalchemy import Column, Integer, String, DateTime, Enum
from sqlalchemy.sql import func
from app.db.database import Base
import enum

class SkillLevel(str, enum.Enum):
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"
    PROFESSIONAL = "professional"

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    phone = Column(String, unique=True, nullable=True)
    hashed_password = Column(String, nullable=False)
    avatar = Column(String, nullable=True)
    skill_level = Column(Enum(SkillLevel), default=SkillLevel.BEGINNER)
    bio = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
```

**backend/app/models/post.py**
```python
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, ARRAY, Text
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.db.database import Base

class Post(Base):
    __tablename__ = "posts"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    content = Column(Text, nullable=False)
    images = Column(ARRAY(String), nullable=True)
    location = Column(String, nullable=True)
    tags = Column(ARRAY(String), nullable=True)
    likes_count = Column(Integer, default=0)
    comments_count = Column(Integer, default=0)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # 关系
    user = relationship("User", backref="posts")
```

**backend/app/models/match.py**
```python
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Enum, Float, Text
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.db.database import Base
import enum

class MatchStatus(str, enum.Enum):
    OPEN = "open"
    FULL = "full"
    COMPLETED = "completed"
    CANCELLED = "cancelled"

class Match(Base):
    __tablename__ = "matches"
    
    id = Column(Integer, primary_key=True, index=True)
    creator_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    title = Column(String, nullable=False)
    description = Column(Text, nullable=True)
    location = Column(String, nullable=False)
    scheduled_time = Column(DateTime(timezone=True), nullable=False)
    max_participants = Column(Integer, default=4)
    skill_requirement = Column(String, nullable=True)
    cost = Column(Float, default=0.0)
    status = Column(Enum(MatchStatus), default=MatchStatus.OPEN)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # 关系
    creator = relationship("User", backref="created_matches")
    participants = relationship("MatchParticipant", back_populates="match")
```

### 3.3 API 路由实现

**backend/app/api/auth.py**
```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from datetime import timedelta
from app.db.database import get_db
from app.core.config import settings
from app.schemas.user import UserCreate, UserResponse, Token
from app.services.auth import create_user, authenticate_user, create_access_token

router = APIRouter(prefix="/auth", tags=["authentication"])

@router.post("/register", response_model=UserResponse)
async def register(user: UserCreate, db: Session = Depends(get_db)):
    """用户注册"""
    return create_user(db, user)

@router.post("/login", response_model=Token)
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """用户登录"""
    user = authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户名或密码错误"
        )
    
    access_token = create_access_token(
        data={"sub": user.username},
        expires_delta=timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    )
    
    return {"access_token": access_token, "token_type": "bearer"}
```

**backend/app/api/posts.py**
```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.db.database import get_db
from app.schemas.post import PostCreate, PostResponse
from app.services.post import create_post, get_posts, get_post_by_id
from app.api.deps import get_current_user
from app.models.user import User

router = APIRouter(prefix="/posts", tags=["posts"])

@router.post("/", response_model=PostResponse, status_code=status.HTTP_201_CREATED)
async def create_new_post(
    post: PostCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """创建新动态"""
    return create_post(db, post, current_user.id)

@router.get("/", response_model=List[PostResponse])
async def list_posts(
    skip: int = 0,
    limit: int = 20,
    db: Session = Depends(get_db)
):
    """获取动态列表"""
    return get_posts(db, skip=skip, limit=limit)

@router.get("/{post_id}", response_model=PostResponse)
async def get_post(post_id: int, db: Session = Depends(get_db)):
    """获取单个动态详情"""
    post = get_post_by_id(db, post_id)
    if not post:
        raise HTTPException(status_code=404, detail="动态不存在")
    return post
```

### 3.4 主应用入口

**backend/main.py**
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.core.config import settings
from app.api import auth, posts, matches, users
from app.db.database import engine, Base

# 创建数据库表
Base.metadata.create_all(bind=engine)

app = FastAPI(title=settings.APP_NAME)

# CORS 配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 生产环境需要指定具体域名
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 注册路由
app.include_router(auth.router)
app.include_router(posts.router)
app.include_router(matches.router)
app.include_router(users.router)

@app.get("/")
async def root():
    return {"message": "Welcome to Tennis Social Platform API"}

@app.get("/health")
async def health_check():
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
```

### 3.5 运行后端服务

```bash
# 开发模式运行
cd backend
uvicorn main:app --reload --host 0.0.0.0 --port 8000

# 访问 API 文档
# http://localhost:8000/docs  (Swagger UI)
# http://localhost:8000/redoc (ReDoc)
```

## 四、前端开发实践 (Flutter)

### 4.1 项目配置

#### API 配置

**flutter_app/lib/config/api_config.dart**
```dart
class ApiConfig {
  // 根据编译模式自动切换环境
  static const String baseUrl = String.fromEnvironment(
    'API_URL',
    defaultValue: kDebugMode 
      ? 'http://localhost:8000'  // 开发环境
      : 'https://api.tennis.yourdomain.com',  // 生产环境
  );
  
  static const int timeout = 10000;  // 超时时间（毫秒）
  
  // API 端点
  static const String authLogin = '/auth/login';
  static const String authRegister = '/auth/register';
  static const String posts = '/posts/';
  static const String matches = '/matches/';
  static const String users = '/users/';
}
```

#### 应用主题配置

**flutter_app/lib/config/theme.dart**
```dart
import 'package:flutter/material.dart';

class AppTheme {
  // 主色调
  static const Color primaryColor = Color(0xFF007AFF);
  static const Color secondaryColor = Color(0xFF5AC8FA);
  static const Color backgroundColor = Color(0xFFF5F5F5);
  
  // 亮色主题
  static ThemeData lightTheme = ThemeData(
    useMaterial3: true,
    colorScheme: ColorScheme.fromSeed(
      seedColor: primaryColor,
      brightness: Brightness.light,
    ),
    scaffoldBackgroundColor: backgroundColor,
    appBarTheme: const AppBarTheme(
      centerTitle: true,
      elevation: 0,
      backgroundColor: Colors.white,
      foregroundColor: Colors.black87,
    ),
    cardTheme: CardTheme(
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
    ),
  );
  
  // 暗色主题（可选）
  static ThemeData darkTheme = ThemeData(
    useMaterial3: true,
    colorScheme: ColorScheme.fromSeed(
      seedColor: primaryColor,
      brightness: Brightness.dark,
    ),
  );
}
```

### 4.2 数据模型定义

**flutter_app/lib/models/user.dart**
```dart
import 'package:json_annotation/json_annotation.dart';

part 'user.g.dart';  // 代码生成文件

@JsonSerializable()
class User {
  final int id;
  final String username;
  final String email;
  final String? phone;
  final String? avatar;
  @JsonKey(name: 'skill_level')
  final String? skillLevel;
  final String? bio;

  User({
    required this.id,
    required this.username,
    required this.email,
    this.phone,
    this.avatar,
    this.skillLevel,
    this.bio,
  });

  // JSON 序列化
  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
  Map<String, dynamic> toJson() => _$UserToJson(this);
}
```

**flutter_app/lib/models/post.dart**
```dart
import 'package:json_annotation/json_annotation.dart';

part 'post.g.dart';

@JsonSerializable()
class Post {
  final int id;
  @JsonKey(name: 'user_id')
  final int userId;
  final String content;
  final List<String>? images;
  final String? location;
  final List<String>? tags;
  @JsonKey(name: 'likes_count')
  final int likesCount;
  @JsonKey(name: 'comments_count')
  final int commentsCount;
  @JsonKey(name: 'created_at')
  final String createdAt;

  Post({
    required this.id,
    required this.userId,
    required this.content,
    this.images,
    this.location,
    this.tags,
    required this.likesCount,
    required this.commentsCount,
    required this.createdAt,
  });

  factory Post.fromJson(Map<String, dynamic> json) => _$PostFromJson(json);
  Map<String, dynamic> toJson() => _$PostToJson(this);
}
```

```bash
# 生成序列化代码
flutter pub run build_runner build --delete-conflicting-outputs
```

### 4.3 状态管理配置 (Riverpod)

#### Riverpod 简介
Riverpod 是 Provider 的升级版，提供更好的类型安全和更简洁的语法。

**核心概念：**
- **Provider**：数据提供者（不可变状态）
- **StateProvider**：简单状态管理（可变状态）
- **StateNotifierProvider**：复杂状态管理（推荐）
- **FutureProvider**：异步数据
- **StreamProvider**：流数据

**flutter_app/lib/providers/auth_provider.dart**
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/user.dart';

// 认证状态类
class AuthState {
  final String? token;
  final User? user;
  final bool isAuthenticated;

  AuthState({
    this.token,
    this.user,
    this.isAuthenticated = false,
  });

  AuthState copyWith({
    String? token,
    User? user,
    bool? isAuthenticated,
  }) {
    return AuthState(
      token: token ?? this.token,
      user: user ?? this.user,
      isAuthenticated: isAuthenticated ?? this.isAuthenticated,
    );
  }
}

// 认证状态管理器
class AuthNotifier extends StateNotifier<AuthState> {
  AuthNotifier() : super(AuthState()) {
    _init();
  }

  // 初始化：从本地存储恢复 token
  Future<void> _init() async {
    final prefs = await SharedPreferences.getInstance();
    final token = prefs.getString('access_token');
    if (token != null) {
      state = state.copyWith(token: token, isAuthenticated: true);
    }
  }

  // 登录
  Future<void> login(String token, User user) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('access_token', token);
    state = state.copyWith(
      token: token,
      user: user,
      isAuthenticated: true,
    );
  }

  // 登出
  Future<void> logout() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove('access_token');
    state = AuthState();
  }
}

// Provider 定义
final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  return AuthNotifier();
});
```

**flutter_app/lib/providers/post_provider.dart**
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/post.dart';
import '../services/post_service.dart';

// 动态列表 Provider（使用 FutureProvider 自动处理异步）
final postsProvider = FutureProvider<List<Post>>((ref) async {
  return await postService.getPosts();
});

// 或使用 StateNotifierProvider 手动管理
class PostsNotifier extends StateNotifier<List<Post>> {
  PostsNotifier() : super([]);

  void setPosts(List<Post> posts) {
    state = posts;
  }

  void addPost(Post post) {
    state = [post, ...state];
  }
}

final postsNotifierProvider = StateNotifierProvider<PostsNotifier, List<Post>>((ref) {
  return PostsNotifier();
});
```

### 4.4 API 服务封装 (Dio)

**flutter_app/lib/services/api_service.dart**
```dart
import 'package:dio/dio.dart';
import '../config/api_config.dart';

class ApiService {
  late Dio _dio;
  String? _token;

  ApiService() {
    _dio = Dio(BaseOptions(
      baseUrl: ApiConfig.baseUrl,
      connectTimeout: const Duration(milliseconds: ApiConfig.timeout),
      receiveTimeout: const Duration(milliseconds: ApiConfig.timeout),
      headers: {
        'Content-Type': 'application/json',
      },
    ));

// 请求拦截器 - 添加 token
    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) {
        if (_token != null) {
          options.headers['Authorization'] = 'Bearer $_token';
        }
        return handler.next(options);
      },
      onError: (error, handler) {
        // 处理 401 未授权错误
        if (error.response?.statusCode == 401) {
          // 跳转到登录页（需要在 main.dart 中处理）
        }
        return handler.next(error);
      },
    ));
  }

  // 设置 token
  void setToken(String? token) {
    _token = token;
  }

  // GET 请求
  Future<Response> get(String path, {Map<String, dynamic>? queryParameters}) {
    return _dio.get(path, queryParameters: queryParameters);
  }

  // POST 请求
  Future<Response> post(String path, {dynamic data}) {
    return _dio.post(path, data: data);
  }

  // PUT 请求
  Future<Response> put(String path, {dynamic data}) {
    return _dio.put(path, data: data);
  }

  // DELETE 请求
  Future<Response> delete(String path) {
    return _dio.delete(path);
  }

  // 上传文件
  Future<Response> uploadFile(String path, String filePath) async {
    FormData formData = FormData.fromMap({
      'file': await MultipartFile.fromFile(filePath),
    });
    return _dio.post(path, data: formData);
  }
}

// 全局单例
final apiService = ApiService();
```

**flutter_app/lib/services/auth_service.dart**
```dart
import 'package:dio/dio.dart';
import '../models/user.dart';
import 'api_service.dart';
import '../config/api_config.dart';

class AuthService {
  // 登录
  Future<Map<String, dynamic>> login({
    required String username,
    required String password,
  }) async {
    try {
      // FastAPI OAuth2 需要 form-data 格式
      final formData = FormData.fromMap({
        'username': username,
        'password': password,
      });

      final response = await apiService.post(
        ApiConfig.authLogin,
        data: formData,
      );

    return response.data;
    } catch (e) {
      throw Exception('登录失败: $e');
    }
  }

  // 注册
  Future<User> register({
    required String username,
    required String email,
    required String password,
  }) async {
    try {
      final response = await apiService.post(
        ApiConfig.authRegister,
        data: {
          'username': username,
          'email': email,
          'password': password,
        },
      );

      return User.fromJson(response.data);
    } catch (e) {
      throw Exception('注册失败: $e');
    }
  }

  // 获取当前用户信息
  Future<User> getCurrentUser() async {
    try {
      final response = await apiService.get('/users/me');
      return User.fromJson(response.data);
    } catch (e) {
      throw Exception('获取用户信息失败: $e');
    }
  }
}

// 全局单例
final authService = AuthService();
```

**flutter_app/lib/services/post_service.dart**
```dart
import '../models/post.dart';
import 'api_service.dart';
import '../config/api_config.dart';

class PostService {
  // 获取动态列表
  Future<List<Post>> getPosts({int skip = 0, int limit = 20}) async {
    try {
      final response = await apiService.get(
        ApiConfig.posts,
        queryParameters: {'skip': skip, 'limit': limit},
      );

      final List<dynamic> data = response.data;
      return data.map((json) => Post.fromJson(json)).toList();
    } catch (e) {
      throw Exception('获取动态列表失败: $e');
    }
  }

  // 创建动态
  Future<Post> createPost({
    required String content,
    List<String>? images,
    String? location,
  }) async {
    try {
      final response = await apiService.post(
        ApiConfig.posts,
        data: {
          'content': content,
          'images': images,
          'location': location,
        },
      );

      return Post.fromJson(response.data);
    } catch (e) {
      throw Exception('创建动态失败: $e');
    }
  }

  // 获取单个动态
  Future<Post> getPost(int postId) async {
    try {
      final response = await apiService.get('${ApiConfig.posts}$postId');
      return Post.fromJson(response.data);
    } catch (e) {
      throw Exception('获取动态详情失败: $e');
    }
  }
}

// 全局单例
final postService = PostService();
```

### 4.5 路由导航配置 (go_router)

**flutter_app/lib/routes/app_router.dart**
```dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/auth_provider.dart';
import '../screens/auth/login_screen.dart';
import '../screens/auth/register_screen.dart';
import '../screens/home/home_screen.dart';

// 路由 Provider
final routerProvider = Provider<GoRouter>((ref) {
  final authState = ref.watch(authProvider);
  
  return GoRouter(
    initialLocation: '/login',
    redirect: (context, state) {
      final isAuthenticated = authState.isAuthenticated;
      final isLoginRoute = state.matchedLocation == '/login' ||
          state.matchedLocation == '/register';

      if (!isAuthenticated && !isLoginRoute) {
        return '/login';
      }
      if (isAuthenticated && isLoginRoute) {
        return '/home';
      }
      return null;
    },
    routes: [
      GoRoute(
        path: '/login',
        builder: (context, state) => const LoginScreen(),
      ),
      GoRoute(
        path: '/register',
        builder: (context, state) => const RegisterScreen(),
      ),
      GoRoute(
        path: '/home',
        builder: (context, state) => const HomeScreen(),
      ),
    ],
  );
});
```

**flutter_app/lib/screens/home/home_screen.dart** (带底部导航栏的主页)
```dart
import 'package:flutter/material.dart';
import '../feed/feed_screen.dart';
import '../matches/matches_screen.dart';
import '../profile/profile_screen.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({Key? key}) : super(key: key);

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  int _currentIndex = 0;

  final List<Widget> _screens = [
    const FeedScreen(),
    const MatchesScreen(),
    const ProfileScreen(),
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: IndexedStack(
        index: _currentIndex,
        children: _screens,
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        onTap: (index) {
          setState(() {
            _currentIndex = index;
          });
        },
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.home_outlined),
            activeIcon: Icon(Icons.home),
            label: '动态',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.sports_tennis_outlined),
            activeIcon: Icon(Icons.sports_tennis),
            label: '约球',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person_outline),
            activeIcon: Icon(Icons.person),
            label: '我的',
          ),
        ],
      ),
    );
  }
}
```

### 4.6 示例页面组件

#### 登录页面

**flutter_app/lib/screens/auth/login_screen.dart**
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../providers/auth_provider.dart';
import '../../services/auth_service.dart';
import '../../services/api_service.dart';

class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({Key? key}) : super(key: key);

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _usernameController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLoading = false;

  @override
  void dispose() {
    _usernameController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleLogin() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      final result = await authService.login(
        username: _usernameController.text,
        password: _passwordController.text,
      );

      final token = result['access_token'];
      final user = await authService.getCurrentUser();
      
      // 使用 Riverpod 更新状态
      await ref.read(authProvider.notifier).login(token, user);
      apiService.setToken(token);
      
      if (mounted) context.go('/home');
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('登录失败: $e')),
        );
      }
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text(
                  '网球社交平台',
                  style: TextStyle(fontSize: 32, fontWeight: FontWeight.bold),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 48),
                TextFormField(
                  controller: _usernameController,
                  decoration: const InputDecoration(
                    labelText: '用户名',
                    prefixIcon: Icon(Icons.person),
                    border: OutlineInputBorder(),
                  ),
                  validator: (value) => 
                      value?.isEmpty ?? true ? '请输入用户名' : null,
                ),
                const SizedBox(height: 16),
                TextFormField(
                  controller: _passwordController,
                  obscureText: true,
                  decoration: const InputDecoration(
                    labelText: '密码',
                    prefixIcon: Icon(Icons.lock),
                    border: OutlineInputBorder(),
                  ),
                  validator: (value) => 
                      value?.isEmpty ?? true ? '请输入密码' : null,
                ),
                const SizedBox(height: 24),
                ElevatedButton(
                  onPressed: _isLoading ? null : _handleLogin,
                  child: _isLoading
                      ? const CircularProgressIndicator()
                      : const Text('登录'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

#### 动态列表页面

**flutter_app/lib/screens/feed/feed_screen.dart**
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../providers/post_provider.dart';
import '../../widgets/post_card.dart';

class FeedScreen extends ConsumerWidget {
  const FeedScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 使用 FutureProvider 自动处理异步数据
    final postsAsync = ref.watch(postsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('动态'),
        actions: [
          IconButton(
            icon: const Icon(Icons.add),
            onPressed: () {
              // 跳转到发布动态页面
            },
          ),
        ],
      ),
      body: postsAsync.when(
        // 加载中
        loading: () => const Center(child: CircularProgressIndicator()),
        // 加载失败
        error: (error, stack) => Center(child: Text('加载失败: $error')),
        // 加载成功
        data: (posts) {
          if (posts.isEmpty) {
            return const Center(child: Text('暂无动态'));
          }
          
          return RefreshIndicator(
            onRefresh: () async {
              // 刷新数据
              ref.invalidate(postsProvider);
            },
            child: ListView.builder(
              itemCount: posts.length,
              itemBuilder: (context, index) => PostCard(post: posts[index]),
            ),
          );
        },
      ),
    );
  }
}
```

#### 动态卡片组件

**flutter_app/lib/widgets/post_card.dart**（简化版）
```dart
import 'package:flutter/material.dart';
import '../models/post.dart';

class PostCard extends StatelessWidget {
  final Post post;

  const PostCard({Key? key, required this.post}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(12),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 用户信息
            Row(
              children: [
                CircleAvatar(child: Text('${post.userId}')),
                const SizedBox(width: 12),
                Text('用户 ${post.userId}', 
                     style: const TextStyle(fontWeight: FontWeight.bold)),
              ],
            ),
            const SizedBox(height: 12),
            
            // 动态内容
            Text(post.content),
            
            // 图片（如果有）
            if (post.images?.isNotEmpty ?? false)
              Padding(
                padding: const EdgeInsets.only(top: 12),
                child: Image.network(post.images!.first, height: 200),
              ),
            
            // 互动按钮
            Row(
              children: [
                IconButton(
                  icon: const Icon(Icons.favorite_border),
                  onPressed: () {},
                ),
                Text('${post.likesCount}'),
                const SizedBox(width: 16),
                IconButton(
                  icon: const Icon(Icons.comment_outlined),
                  onPressed: () {},
                ),
                Text('${post.commentsCount}'),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
```

### 4.7 App 入口文件

**flutter_app/lib/main.dart**（使用 Riverpod）
```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_screenutil/flutter_screenutil.dart';
import 'config/theme.dart';
import 'routes/app_router.dart';

void main() {
  runApp(
    // ProviderScope 是 Riverpod 的根容器
    const ProviderScope(
      child: MyApp(),
    ),
  );
}

class MyApp extends ConsumerWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 监听路由 Provider
    final router = ref.watch(routerProvider);

    return ScreenUtilInit(
      designSize: const Size(375, 812),
      builder: (context, child) {
        return MaterialApp.router(
          title: '网球社交平台',
          theme: AppTheme.lightTheme,
          routerConfig: router,
          debugShowCheckedModeBanner: false,
        );
      },
    );
  }
}
```

**Riverpod 使用说明：**

1. **读取状态**
```dart
// 在 Widget 中
final authState = ref.watch(authProvider);
final isAuthenticated = authState.isAuthenticated;

// 只读一次（不监听变化）
final authState = ref.read(authProvider);
```

2. **修改状态**
```dart
// 调用 Notifier 方法
await ref.read(authProvider.notifier).login(token, user);
await ref.read(authProvider.notifier).logout();
```

3. **刷新数据**
```dart
// 重新加载 FutureProvider
ref.invalidate(postsProvider);

// 或强制刷新
ref.refresh(postsProvider);
```

## 五、Docker 容器化部署

### 5.1 Docker 部署概述

使用 Docker 部署的优势：
- ✅ 环境一致性：开发、测试、生产环境完全一致
- ✅ 快速部署：一键启动所有服务
- ✅ 易于扩展：支持 Docker Compose 和 Kubernetes
- ✅ 隔离性好：各服务独立运行，互不干扰

**部署架构：**
```
┌─────────────────────────────────────┐
│         Nginx (反向代理)             │
│         端口: 80/443                 │
└──────────┬──────────────────────────┘
           │
    ┌──────┴──────┐
    │             │
┌───▼────┐   ┌───▼────┐
│ FastAPI│   │ Flutter│
│ 后端    │   │ Web    │
│ :8000  │   │ :3000  │
└───┬────┘   └────────┘
    │
┌───▼────────┐
│ PostgreSQL │
│   :5432    │
└────────────┘
```

### 5.2 后端 Docker 配置

#### Dockerfile（后端）

**backend/Dockerfile**
```dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装 Python 依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### .dockerignore（后端）

**backend/.dockerignore**
```
__pycache__
*.pyc
*.pyo
*.pyd
.Python
venv/
env/
.env
.git
.gitignore
.pytest_cache
.coverage
htmlcov/
```

### 5.3 Docker Compose 配置

#### 数据库选择说明

Docker Compose 中的 PostgreSQL 有两种使用方式：

**方案 A：Docker PostgreSQL（推荐用于开发/测试）**
- ✅ 完全容器化，环境一致
- ✅ 易于重置和清理
- ✅ 适合本地开发和 CI/CD
- ⚠️ 数据持久化需要配置 volume

**方案 B：外部 PostgreSQL（推荐用于生产）**
- ✅ 使用云 RDS，性能和可靠性更好
- ✅ 自动备份和高可用
- ✅ 独立扩展
- ⚠️ 需要配置网络连接

**docker-compose.yml**（项目根目录 - 包含 PostgreSQL）
```yaml
version: '3.8'

services:
  # PostgreSQL 数据库（本地开发/测试用）
  postgres:
    image: postgres:15-alpine
    container_name: tennis_postgres
    environment:
      POSTGRES_DB: tennis_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: your_password_here
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # 可选：导入初始化脚本
      # - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - tennis_network

  # FastAPI 后端
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: tennis_backend
    environment:
      DATABASE_URL: postgresql://postgres:your_password_here@postgres:5432/tennis_db
      SECRET_KEY: your-secret-key-change-in-production
      ALIYUN_OSS_ACCESS_KEY_ID: ${ALIYUN_OSS_ACCESS_KEY_ID}
      ALIYUN_OSS_ACCESS_KEY_SECRET: ${ALIYUN_OSS_ACCESS_KEY_SECRET}
      ALIYUN_OSS_BUCKET_NAME: ${ALIYUN_OSS_BUCKET_NAME}
      ALIYUN_OSS_ENDPOINT: ${ALIYUN_OSS_ENDPOINT}
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      - ./backend:/app
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload

  # Nginx 反向代理
  nginx:
    image: nginx:alpine
    container_name: tennis_nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - backend

volumes:
  postgres_data:

networks:
  tennis_network:
    driver: bridge
```

**docker-compose.prod.yml**（生产环境 - 使用云 RDS）
```yaml
version: '3.8'

services:
  # 生产环境不使用 Docker PostgreSQL
  # 注释掉 postgres 服务
  
  backend:
    environment:
      # 使用云 RDS 连接
      DATABASE_URL: postgresql://username:password@rm-xxxxx.pg.rds.aliyuncs.com:5432/tennis_db
      DEBUG: "False"
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4
    restart: always
    # 移除 depends_on postgres

  nginx:
    restart: always

# 生产环境不需要 postgres_data volume
```

**使用方式：**

```bash
# 本地开发（使用 Docker PostgreSQL）
docker-compose up -d

# 生产部署（使用云 RDS）
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
```

### 5.4 Nginx 配置

**nginx/nginx.conf**
```nginx
events {
    worker_connections 1024;
}

http {
    upstream backend {
        server backend:8000;
    }

    server {
        listen 80;
        server_name api.yourdomain.com;

        # API 代理
        location /api/ {
            proxy_pass http://backend/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # 健康检查
        location /health {
            proxy_pass http://backend/health;
        }

        # 文件上传大小限制
        client_max_body_size 10M;
    }

    # HTTPS 配置（可选）
    # server {
    #     listen 443 ssl http2;
    #     server_name api.yourdomain.com;
    #     
    #     ssl_certificate /etc/nginx/ssl/cert.pem;
    #     ssl_certificate_key /etc/nginx/ssl/key.pem;
    #     
    #     location / {
    #         proxy_pass http://backend;
    #     }
    # }
}
```

### 5.5 环境变量配置

**.env**（项目根目录）
```env
# 数据库配置
POSTGRES_DB=tennis_db
POSTGRES_USER=postgres
POSTGRES_PASSWORD=your_secure_password

# 后端配置
SECRET_KEY=your-secret-key-min-32-characters
DATABASE_URL=postgresql://postgres:your_secure_password@postgres:5432/tennis_db

# 阿里云 OSS（可选）
ALIYUN_OSS_ACCESS_KEY_ID=your_access_key_id
ALIYUN_OSS_ACCESS_KEY_SECRET=your_access_key_secret
ALIYUN_OSS_BUCKET_NAME=tennis-social
ALIYUN_OSS_ENDPOINT=oss-cn-hangzhou.aliyuncs.com
```

### 5.6 Docker 部署命令

#### 本地开发环境

```bash
# 启动所有服务
docker-compose up -d

# 查看日志
docker-compose logs -f

# 查看特定服务日志
docker-compose logs -f backend

# 停止所有服务
docker-compose down

# 停止并删除数据卷
docker-compose down -v

# 重新构建并启动
docker-compose up -d --build
```

#### 数据库迁移

```bash
# 进入后端容器
docker-compose exec backend bash

# 运行迁移
alembic upgrade head

# 退出容器
exit
```

#### 生产环境部署

```bash
# 使用生产配置启动
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

# 查看运行状态
docker-compose ps

# 查看资源使用
docker stats
```

### 5.7 生产环境优化配置

**docker-compose.prod.yml**
```yaml
version: '3.8'

services:
  backend:
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4
    restart: always
    volumes: []  # 生产环境不挂载代码目录

  postgres:
    restart: always
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backups:/backups  # 备份目录

  nginx:
    restart: always
```

### 5.8 数据备份与恢复

**备份脚本**（backup.sh）
```bash
#!/bin/bash
# 数据库备份脚本

BACKUP_DIR="./backups"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/tennis_db_$DATE.sql"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 备份数据库
docker-compose exec -T postgres pg_dump -U postgres tennis_db > $BACKUP_FILE

# 压缩备份文件
gzip $BACKUP_FILE

echo "备份完成: ${BACKUP_FILE}.gz"

# 删除 7 天前的备份
find $BACKUP_DIR -name "*.gz" -mtime +7 -delete
```

**恢复脚本**（restore.sh）
```bash
#!/bin/bash
# 数据库恢复脚本

if [ -z "$1" ]; then
    echo "用法: ./restore.sh <备份文件>"
    exit 1
fi

BACKUP_FILE=$1

# 解压备份文件（如果是压缩的）
if [[ $BACKUP_FILE == *.gz ]]; then
    gunzip -c $BACKUP_FILE | docker-compose exec -T postgres psql -U postgres tennis_db
else
    docker-compose exec -T postgres psql -U postgres tennis_db < $BACKUP_FILE
fi

echo "恢复完成"
```

## 六、阿里云部署实践

### 6.1 阿里云 Docker 部署

#### 准备工作

**购买资源：**
- **ECS 云服务器**：2核4GB，Ubuntu 20.04 LTS
- **域名**：已备案并解析到 ECS IP
- **OSS 对象存储**（可选）：用于图片存储

#### 服务器环境配置

```bash
# SSH 连接到 ECS
ssh root@your-server-ip

# 更新系统
apt update && apt upgrade -y

# 安装 Docker
curl -fsSL https://get.docker.com | sh

# 启动 Docker
systemctl start docker
systemctl enable docker

# 安装 Docker Compose
curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose

# 验证安装
docker --version
docker-compose --version
```

#### 部署应用

```bash
# 创建项目目录
mkdir -p /var/www/tennis_app
cd /var/www/tennis_app

# 克隆代码（或使用 scp 上传）
git clone your-repository-url .

# 创建必要的目录
mkdir -p nginx/ssl backups

# 配置环境变量
nano .env
# 填入生产环境配置

# 启动服务
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

# 查看日志
docker-compose logs -f

# 运行数据库迁移
docker-compose exec backend alembic upgrade head
```

#### SSL 证书配置（Let's Encrypt）

```bash
# 安装 certbot
apt install certbot

# 申请证书
certbot certonly --standalone -d api.yourdomain.com

# 证书会保存在 /etc/letsencrypt/live/api.yourdomain.com/

# 复制证书到项目目录
cp /etc/letsencrypt/live/api.yourdomain.com/fullchain.pem nginx/ssl/cert.pem
cp /etc/letsencrypt/live/api.yourdomain.com/privkey.pem nginx/ssl/key.pem

# 重启 nginx
docker-compose restart nginx

# 设置自动续期
crontab -e
# 添加：0 0 1 * * certbot renew && docker-compose restart nginx
```

### 6.2 数据库环境切换指南

#### 开发流程建议

```
本地开发 (localhost PostgreSQL)
    ↓
    测试通过
    ↓
云端测试 (阿里云 RDS)
    ↓
    上线部署
    ↓
生产环境 (阿里云 RDS)
```

#### 环境配置管理

**方案 A：使用不同的 .env 文件（推荐）**

```bash
backend/
├── .env.local          # 本地开发配置
├── .env.test           # 测试环境配置
├── .env.production     # 生产环境配置
└── .env                # 当前使用的配置（git ignore）
```

**backend/.env.local**
```env
DATABASE_URL=postgresql://tennis_user:password@localhost:5432/tennis_db
DEBUG=True
```

**backend/.env.production**
```env
DATABASE_URL=postgresql://username:password@rm-xxxxx.pg.rds.aliyuncs.com:5432/tennis_db
DEBUG=False
```

**切换环境：**
```bash
# 切换到本地开发
cp .env.local .env

# 切换到生产环境
cp .env.production .env
```

**方案 B：使用环境变量**

```python
# backend/app/core/config.py
import os

class Settings(BaseSettings):
    # 根据环境自动选择数据库
    ENVIRONMENT: str = os.getenv("ENVIRONMENT", "local")
    
    @property
    def DATABASE_URL(self) -> str:
        if self.ENVIRONMENT == "production":
            return os.getenv("PROD_DATABASE_URL")
        else:
            return os.getenv("LOCAL_DATABASE_URL", 
                           "postgresql://tennis_user:password@localhost:5432/tennis_db")
```

#### 数据迁移最佳实践

**1. 使用 Alembic 管理数据库版本**

```bash
# 本地开发创建迁移
alembic revision --autogenerate -m "add user table"

# 应用迁移
alembic upgrade head

# 同样的迁移可以在云端执行
# 只需切换 DATABASE_URL 即可
```

**2. 数据同步脚本**

创建 `backend/scripts/sync_to_cloud.sh`：

```bash
#!/bin/bash
# 同步本地数据到云端（谨慎使用！）

echo "导出本地数据..."
pg_dump -U tennis_user -h localhost tennis_db > backup.sql

echo "导入到云端..."
psql -h rm-xxxxx.pg.rds.aliyuncs.com -U username -d tennis_db < backup.sql

echo "同步完成！"
```

**3. 测试数据管理**

```bash
# 本地使用测试数据
# 云端使用真实数据（小规模）
# 生产环境使用完整数据
```

#### 成本优化建议

| 阶段 | 数据库方案 | 月成本 | 说明 |
|------|-----------|--------|------|
| 本地开发 | 本地 PostgreSQL | ¥0 | 完全免费 |
| 测试阶段 | 阿里云 RDS 基础版 | ~¥50-100 | 按需开启 |
| 小规模上线 | 阿里云 RDS 基础版 | ~¥100-200 | 1核2GB |
| 正式运营 | 阿里云 RDS 高可用版 | ~¥500+ | 2核4GB+ |

**省钱技巧：**
- ✅ 开发阶段全部使用本地 PostgreSQL
- ✅ 测试时临时开启云 RDS，测试完关闭
- ✅ 使用阿里云学生优惠或新用户优惠
- ✅ 选择按量付费，而非包年包月（前期）

### 6.3 监控与维护

#### 查看服务状态

```bash
# 查看所有容器状态
docker-compose ps

# 查看资源使用
docker stats

# 查看日志
docker-compose logs -f backend
docker-compose logs -f postgres
docker-compose logs -f nginx
```

#### 更新应用

```bash
# 拉取最新代码
git pull origin main

# 重新构建并启动
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d --build

# 运行数据库迁移（如有）
docker-compose exec backend alembic upgrade head
```

#### 定时备份

```bash
# 设置定时备份（每天凌晨 2 点）
crontab -e
# 添加：0 2 * * * /var/www/tennis_app/backup.sh
```

### 6.3 配置阿里云 OSS（图片上传）

**backend/app/services/oss.py**
```python
import oss2
from app.core.config import settings

class OSSService:
    def __init__(self):
        auth = oss2.Auth(
            settings.ALIYUN_OSS_ACCESS_KEY_ID,
            settings.ALIYUN_OSS_ACCESS_KEY_SECRET
        )
        self.bucket = oss2.Bucket(
            auth,
            settings.ALIYUN_OSS_ENDPOINT,
            settings.ALIYUN_OSS_BUCKET_NAME
        )
    
    def upload_file(self, file_path: str, file_data: bytes) -> str:
        """上传文件到 OSS"""
        self.bucket.put_object(file_path, file_data)
        # 返回文件 URL
        return f"https://{settings.ALIYUN_OSS_BUCKET_NAME}.{settings.ALIYUN_OSS_ENDPOINT}/{file_path}"
    
    def delete_file(self, file_path: str):
        """删除 OSS 文件"""
        self.bucket.delete_object(file_path)

oss_service = OSSService()
```

### 6.4 数据库配置方案总结

#### 快速参考表

| 场景 | 数据库方案 | 配置方式 | 优势 | 成本 |
|------|-----------|---------|------|------|
| **本地开发** | 本地 PostgreSQL | 直接安装 | 快速、免费 | ¥0 |
| **Docker 开发** | Docker PostgreSQL | docker-compose.yml | 环境一致 | ¥0 |
| **团队协作** | 共享测试 RDS | 云 RDS 基础版 | 数据同步 | ~¥50/月 |
| **生产环境** | 云 RDS 高可用 | docker-compose.prod.yml | 高可用、备份 | ~¥500+/月 |

#### 推荐开发流程

```
阶段 1：本地开发
├── 本地 PostgreSQL
├── 快速迭代
└── 成本：¥0

阶段 2：功能测试
├── Docker PostgreSQL
├── 环境一致性测试
└── 成本：¥0

阶段 3：集成测试
├── 阿里云 RDS 基础版
├── 真实环境测试
└── 成本：~¥50-100/月

阶段 4：上线部署
├── 阿里云 RDS 高可用版
├── 自动备份 + 监控
└── 成本：根据规模调整
```

#### 数据库连接字符串示例

```bash
# 本地开发
DATABASE_URL=postgresql://tennis_user:password@localhost:5432/tennis_db

# Docker 容器内连接
DATABASE_URL=postgresql://postgres:password@postgres:5432/tennis_db

# 阿里云 RDS（内网）
DATABASE_URL=postgresql://username:password@rm-xxxxx.pg.rds.aliyuncs.com:5432/tennis_db

# 阿里云 RDS（外网，不推荐生产使用）
DATABASE_URL=postgresql://username:password@rm-xxxxx.pg.rds.aliyuncs.com:3433/tennis_db
```

### 6.5 Flutter 应用发布

Flutter 应用发布流程请参考前面 **4.7 节**的详细说明，包括：
- Android APK/AAB 打包
- iOS IPA 打包
- 应用商店发布流程
- 版本管理

## 七、开发最佳实践

### 7.1 Git 工作流
```bash
# 功能分支开发
git checkout -b feature/post-creation
# 开发完成后
git add .
git commit -m "feat: 添加动态发布功能"
git push origin feature/post-creation
# 创建 Pull Request 合并到 main
```

### 7.2 代码规范
- **Python：** 遵循 PEP 8
- **Dart：** 使用 `flutter analyze` 和 `dart format`
- **Git Commit：** 遵循 Conventional Commits

**配置 Dart 代码规范**

创建 `flutter_app/analysis_options.yaml`：
```yaml
include: package:flutter_lints/flutter.yaml

linter:
  rules:
    - prefer_const_constructors
    - prefer_const_literals_to_create_immutables
    - avoid_print
    - prefer_single_quotes
    - always_declare_return_types
    - require_trailing_commas

analyzer:
  exclude:
    - "**/*.g.dart"
    - "**/*.freezed.dart"
```

**代码格式化命令**
```bash
# 格式化所有 Dart 代码
dart format lib/

# 分析代码问题
flutter analyze

# 修复可自动修复的问题
dart fix --apply
```

### 7.3 测试策略

**后端测试**
```bash
# Python 单元测试
cd backend
pytest tests/
```

**Flutter 测试**
```bash
cd flutter_app

# 单元测试
flutter test

# 集成测试
flutter test integration_test/

# 测试覆盖率
flutter test --coverage
```

**Flutter 测试示例**

`flutter_app/test/services/auth_service_test.dart`：
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:tennis_app/services/auth_service.dart';

void main() {
  group('AuthService Tests', () {
    test('login should return token', () async {
      // 测试逻辑
    });
    
    test('register should create user', () async {
      // 测试逻辑
    });
  });
}
```

### 7.4 性能优化

**后端优化**
- 数据库索引优化
- API 响应缓存（Redis）
- 图片压缩和 CDN 加速
- 分页加载

**Flutter 性能优化**
- 使用 `const` 构造函数减少重建
- 使用 `ListView.builder` 而非 `ListView`（懒加载）
- 图片缓存：使用 `cached_network_image`
- 避免不必要的 `setState()`
- 使用 `RepaintBoundary` 隔离重绘区域
- 使用 DevTools 分析性能瓶颈

**Flutter 性能分析**
```bash
# 性能分析
flutter run --profile

# 在 DevTools 中查看性能
flutter pub global activate devtools
flutter pub global run devtools
```

### 7.5 安全最佳实践
- HTTPS 加密传输
- JWT Token 认证
- SQL 注入防护（使用 ORM）
- XSS 防护
- 敏感信息环境变量存储
- 定期安全更新

## 八、监控和运维

### 8.1 Docker 日志管理
```bash
# 查看容器日志
docker-compose logs -f backend
docker-compose logs -f postgres
docker-compose logs -f nginx

# 查看最近 100 行日志
docker-compose logs --tail=100 backend

# 导出日志
docker-compose logs backend > backend.log
```

### 8.2 性能监控

```bash
# 查看容器资源使用
docker stats

# 查看磁盘使用
df -h

# 查看数据库性能
docker-compose exec postgres psql -U postgres -d tennis_db -c "SELECT * FROM pg_stat_activity;"
```

### 8.3 备份策略

数据备份请参考前面 **5.8 节**的备份脚本，包括：
- 自动备份脚本
- 恢复脚本
- 定时任务配置

## 九、持续集成/部署（CI/CD）

### 9.1 GitHub Actions 示例

**.github/workflows/deploy.yml**（Docker 部署）
```yaml
name: Deploy to Aliyun

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            cd /var/www/tennis_app
            git pull origin main
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d --build
            docker-compose exec -T backend alembic upgrade head
```

## 十、开发时间线

### 第1-2周：环境搭建和基础框架
- 开发环境配置
- 项目初始化
- 数据库设计
- 基础 API 框架

### 第3-4周：用户系统
- 注册登录功能
- JWT 认证
- 用户信息管理

### 第5-6周：动态发布功能
- 动态 CRUD API
- 图片上传 OSS
- 前端动态页面

### 第7-8周：约球功能
- 约球 CRUD API
- 约球列表和筛选
- 参与者管理

### 第9-10周：社交互动
- 点赞评论功能
- 关注系统
- 消息通知

### 第11-12周：测试和部署
- 功能测试
- 性能优化
- 阿里云部署
- 应用发布

## 十一、学习资源

### 官方文档
- **Flutter:** https://flutter.dev/docs（中文：https://flutter.cn/）
- **Dart 语言:** https://dart.dev/guides
- **Riverpod:** https://riverpod.dev/（推荐状态管理）
- **go_router:** https://pub.dev/packages/go_router
- **Dio:** https://pub.dev/packages/dio
- **FastAPI:** https://fastapi.tiangolo.com/
- **PostgreSQL:** https://www.postgresql.org/docs/
- **阿里云文档:** https://help.aliyun.com/

### Riverpod 快速上手

**三种常用 Widget：**
- `ConsumerWidget`：替代 StatelessWidget，可访问 ref
- `ConsumerStatefulWidget`：替代 StatefulWidget，可访问 ref
- `Consumer`：局部监听 Provider

**示例：**
```dart
// 1. ConsumerWidget（无状态）
class MyWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final value = ref.watch(myProvider);
    return Text(value);
  }
}

// 2. ConsumerStatefulWidget（有状态）
class MyWidget extends ConsumerStatefulWidget {
  @override
  ConsumerState<MyWidget> createState() => _MyWidgetState();
}

class _MyWidgetState extends ConsumerState<MyWidget> {
  @override
  Widget build(BuildContext context) {
    final value = ref.watch(myProvider);
    return Text(value);
  }
}

// 3. Consumer（局部监听）
Text('固定内容'),
Consumer(
  builder: (context, ref, child) {
    final value = ref.watch(myProvider);
    return Text(value);
  },
)
```

### 推荐教程

**Flutter 学习路径**
1. **官方教程**
   - Flutter 官方文档（中文）：https://flutter.cn/
   - Dart 语言之旅：https://dart.cn/guides/language/language-tour
   - Flutter Codelabs：https://flutter.dev/docs/codelabs

2. **视频教程**
   - Flutter 官方 YouTube 频道
   - 网易云课堂 Flutter 课程
   - B站 Flutter 教程

3. **实战项目**
   - Flutter Gallery（官方示例）
   - FlutterFire（Firebase 集成）
   - awesome-flutter（优秀项目集合）

4. **社区资源**
   - Flutter 中文社区：https://flutter.cn/community
   - Flutter 中文开发者：https://flutterchina.club/
   - Pub.dev 包仓库：https://pub.dev/

**后端学习**
- FastAPI 实战教程
- PostgreSQL 数据库设计
- 阿里云部署最佳实践

### Flutter 常见问题

**1. 环境配置问题**
```bash
# 检查环境
flutter doctor -v

# 常见问题：
# - Android licenses 未接受：flutter doctor --android-licenses
# - Xcode 未安装：从 App Store 安装
# - 网络问题：配置镜像（见官方文档）
```

**2. 包依赖问题**
```bash
# 清理缓存
flutter clean
flutter pub get

# 更新依赖
flutter pub upgrade
```

**3. 热重载不生效**
- 按 `r` 热重载，`R` 热重启
- 某些改动需要热重启（如添加新资源）

**4. 调试技巧**
```dart
// 打印调试信息
print('Debug: $variable');
debugPrint('Debug message');

// 使用断点
// 在 VS Code/Android Studio 中设置断点

// 查看 Widget 树
// 使用 Flutter DevTools
```

---

## 十二、Flutter vs React Native 对比

| 特性 | Flutter | React Native |
|------|---------|--------------|
| **语言** | Dart | JavaScript/TypeScript |
| **性能** | 接近原生（直接编译） | 较好（JS Bridge） |
| **UI 渲染** | 自绘引擎（Skia） | 原生组件 |
| **热重载** | 支持 | 支持 |
| **学习曲线** | 中等（需学 Dart） | 较低（Web 开发者友好） |
| **社区生态** | 快速增长 | 成熟丰富 |
| **包管理** | Pub.dev | npm |
| **适用场景** | 高性能、复杂 UI | 快速开发、Web 技术栈 |

**选择 Flutter 的理由：**
- ✅ 更好的性能和流畅度
- ✅ 一致的跨平台体验
- ✅ 丰富的 UI 组件库
- ✅ Google 官方支持
- ✅ 适合长期维护的项目

---

**开发建议：**
1. **循序渐进**：先掌握 Dart 基础，再学习 Flutter Widget
2. **实践为主**：通过实际项目学习，边做边学
3. **代码质量**：重视代码规范和可维护性
4. **性能优化**：使用 DevTools 分析性能瓶颈
5. **社区参与**：多参考优秀开源项目，参与社区讨论
6. **持续学习**：关注 Flutter 官方更新和最佳实践

**Flutter 开发效率提升技巧：**
- 使用 Flutter Snippets 插件（快速生成代码）
- 掌握快捷键（热重载 `r`、热重启 `R`）
- 使用 DevTools 调试和性能分析
- 善用 `flutter pub outdated` 检查依赖更新
- 阅读官方 Widget of the Week 系列

祝开发顺利！🎾🚀

